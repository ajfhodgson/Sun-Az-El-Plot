<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Solar Position Plotter</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/3.9.1/chart.min.js"></script>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
        }
        
        .container {
            background: rgba(255, 255, 255, 0.95);
            border-radius: 20px;
            padding: 30px;
            box-shadow: 0 20px 40px rgba(0,0,0,0.1);
            backdrop-filter: blur(10px);
        }
        
        h1 {
            text-align: center;
            color: #333;
            margin-bottom: 30px;
            font-size: 2.5em;
            background: linear-gradient(45deg, #667eea, #764ba2);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }
        
        .input-group {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
            padding: 20px;
            background: rgba(102, 126, 234, 0.1);
            border-radius: 15px;
            border: 2px solid rgba(102, 126, 234, 0.2);
        }
        
        .form-group {
            display: flex;
            flex-direction: column;
        }
        
        label {
            font-weight: 600;
            margin-bottom: 8px;
            color: #555;
            font-size: 0.95em;
        }
        
        input, select {
            padding: 12px 15px;
            border: 2px solid #ddd;
            border-radius: 10px;
            font-size: 16px;
            transition: all 0.3s ease;
            background: white;
        }
        
        input:focus, select:focus {
            outline: none;
            border-color: #667eea;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
            transform: translateY(-2px);
        }
        
        button {
            grid-column: 1 / -1;
            background: linear-gradient(45deg, #667eea, #764ba2);
            color: white;
            border: none;
            padding: 15px 30px;
            border-radius: 12px;
            font-size: 18px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        
        button:hover {
            transform: translateY(-3px);
            box-shadow: 0 10px 25px rgba(102, 126, 234, 0.3);
        }
        
        button:disabled {
            background: #ccc;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }
        
        .chart-container {
            position: relative;
            margin: 30px 0;
            padding: 20px;
            background: white;
            border-radius: 15px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.1);
        }
        
        .download-btn {
            display: block;
            width: 200px;
            margin: 20px auto;
            background: linear-gradient(45deg, #28a745, #20c997);
            padding: 12px 25px;
            border-radius: 10px;
            text-decoration: none;
            color: white;
            text-align: center;
            font-weight: 600;
            transition: all 0.3s ease;
        }
        
        .download-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 20px rgba(40, 167, 69, 0.3);
        }
        
        .status {
            text-align: center;
            padding: 15px;
            margin: 20px 0;
            border-radius: 10px;
            font-weight: 500;
        }
        
        .loading {
            background: rgba(255, 193, 7, 0.1);
            color: #856404;
            border: 2px solid rgba(255, 193, 7, 0.2);
        }
        
        .error {
            background: rgba(220, 53, 69, 0.1);
            color: #721c24;
            border: 2px solid rgba(220, 53, 69, 0.2);
        }
        
        .info {
            background: rgba(13, 202, 240, 0.1);
            color: #055160;
            border: 2px solid rgba(13, 202, 240, 0.2);
            margin-top: 20px;
            text-align: left;
        }
        
        canvas {
            max-width: 100% !important;
            height: auto !important;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>ðŸŒž Solar Position Plotter</h1>
        
        <div class="input-group">
            <div class="form-group">
                <label for="latitude">Latitude (Â°)</label>
                <input type="number" id="latitude" value="52.0" step="0.1" min="-90" max="90" required>
            </div>
            
            <div class="form-group">
                <label for="longitude">Longitude (Â°)</label>
                <input type="number" id="longitude" value="0.0" step="0.1" min="-180" max="180" required>
            </div>
            
            <div class="form-group">
                <label for="declination">Declination West of South (Â°)</label>
                <input type="number" id="declination" value="0.0" step="0.1" min="-180" max="180">
            </div>
            
            <div class="form-group">
                <label for="interval">Time Interval (minutes)</label>
                <select id="interval">
                    <option value="10">10 minutes</option>
                    <option value="15" selected>15 minutes</option>
                    <option value="30">30 minutes</option>
                    <option value="60">1 hour</option>
                </select>
            </div>
            
            <div class="form-group">
                <label for="motto">Motto or Address</label>
                <input type="text" id="motto" placeholder="e.g., Observatory Name, Your Address..." maxlength="100">
            </div>
            
            <button onclick="generatePlot()">Generate Solar Position Plot</button>
        </div>
        
        <div id="status"></div>
        
        <div class="chart-container" id="chartContainer" style="display: none;">
            <canvas id="solarChart" width="800" height="800"></canvas>
            <a id="downloadBtn" class="download-btn" style="display: none;">ðŸ“¥ Download High-Res PNG</a>
        </div>
        
        <div class="info">
            <h3>How to read this chart:</h3>
            <ul>
                <li><strong>Radial Direction:</strong> Points outward from center represent higher sun elevation angles</li>
                <li><strong>Angular Position:</strong> Azimuth angle (North at top, East at right, South at bottom, West at left)</li>
                <li><strong>Colors:</strong> Each month has a distinct color - watch how the sun's path changes throughout the year</li>
                <li><strong>Black Circle:</strong> Represents the horizon (elevation = 0Â°)</li>
                <li><strong>Hour Markers:</strong> Larger dots mark each hour, smaller dots show intermediate intervals</li>
                <li><strong>Gray Points:</strong> Sun below horizon (nighttime)</li>
            </ul>
        </div>
    </div>

    <script>
        // Solar position calculation functions
        function toRadians(degrees) {
            return degrees * (Math.PI / 180);
        }
        
        function toDegrees(radians) {
            return radians * (180 / Math.PI);
        }
        
        function julianDay(date) {
            const a = Math.floor((14 - date.getMonth() - 1) / 12);
            const y = date.getFullYear() + 4800 - a;
            const m = date.getMonth() + 1 + 12 * a - 3;
            return date.getDate() + Math.floor((153 * m + 2) / 5) + 365 * y + Math.floor(y / 4) - Math.floor(y / 100) + Math.floor(y / 400) - 32045;
        }
        
        function solarPosition(date, latitude, longitude) {
            const lat = toRadians(latitude);
            const jd = julianDay(date);
            const n = jd - 2451545.0;
            
            // More accurate solar position calculation including equation of time
            const L = (280.460 + 0.9856474 * n) % 360; // Mean longitude of sun
            const g = toRadians((357.528 + 0.9856003 * n) % 360); // Mean anomaly
            const lambda = toRadians(L + 1.915 * Math.sin(g) + 0.020 * Math.sin(2 * g)); // True longitude
            
            // Obliquity of ecliptic
            const obliquity = toRadians(23.439 - 0.0000004 * n);
            
            // Right ascension and declination
            const alpha = Math.atan2(Math.cos(obliquity) * Math.sin(lambda), Math.cos(lambda));
            const delta = Math.asin(Math.sin(obliquity) * Math.sin(lambda));
            
            // Equation of time (in minutes)
            const eot = 4 * toDegrees(toRadians(L) - 0.0057183 - alpha);
            
            // Local solar time
            const hours = date.getHours() + date.getMinutes() / 60 + date.getSeconds() / 3600;
            const solarTime = hours + eot / 60; // Apply equation of time correction
            
            // Hour angle
            const h = toRadians(15 * (solarTime - 12) + longitude);
            
            // Solar elevation and azimuth
            const elevation = Math.asin(Math.sin(lat) * Math.sin(delta) + Math.cos(lat) * Math.cos(delta) * Math.cos(h));
            const azimuth = Math.atan2(Math.sin(h), Math.cos(h) * Math.sin(lat) - Math.tan(delta) * Math.cos(lat));
            
            let azimuthDeg = toDegrees(azimuth);
            if (azimuthDeg < 0) azimuthDeg += 360;
            
            return {
                elevation: toDegrees(elevation),
                azimuth: azimuthDeg
            };
        }
        
        function generatePlot() {
            const latitude = parseFloat(document.getElementById('latitude').value);
            const longitude = parseFloat(document.getElementById('longitude').value);
            const declination = parseFloat(document.getElementById('declination').value) || 0;
            const motto = document.getElementById('motto').value || '';
            const year = 2025; // Fixed year
            const interval = parseInt(document.getElementById('interval').value);
            
            if (isNaN(latitude) || isNaN(longitude)) {
                showStatus('Please enter valid latitude and longitude values.', 'error');
                return;
            }
            
            if (latitude < -90 || latitude > 90) {
                showStatus('Latitude must be between -90 and 90 degrees.', 'error');
                return;
            }
            
            if (longitude < -180 || longitude > 180) {
                showStatus('Longitude must be between -180 and 180 degrees.', 'error');
                return;
            }
            
            showStatus('Calculating solar positions... This may take a moment.', 'loading');
            document.querySelector('button').disabled = true;
            
            setTimeout(() => {
                try {
                    const data = calculateSolarData(latitude, longitude, year, interval);
                    createPolarChart(data, latitude, longitude, declination, motto);
                    showStatus('Solar position chart generated successfully!', 'success');
                } catch (error) {
                    showStatus('Error generating chart: ' + error.message, 'error');
                }
                document.querySelector('button').disabled = false;
            }, 100);
        }
        
        function calculateSolarData(latitude, longitude, year, interval) {
            const data = [];
            const monthColors = [
                '#FF0000', '#FFA500', '#FFFF00', '#008000', '#0000FF', '#800080',
                '#FF0000', '#FFA500', '#FFFF00', '#008000', '#0000FF', '#800080'
            ];
            
            // Calculate for EVERY day of the year to capture analemma patterns
            for (let month = 0; month < 12; month++) {
                const daysInMonth = new Date(year, month + 1, 0).getDate();
                
                for (let day = 1; day <= daysInMonth; day++) { // Every day, not sampling
                    for (let minutes = 0; minutes < 1440; minutes += interval) {
                        const date = new Date(year, month, day, 0, minutes, 0);
                        const pos = solarPosition(date, latitude, longitude);
                        
                        const isHourly = minutes % 60 === 0;
                        
                        data.push({
                            azimuth: pos.azimuth,
                            elevation: pos.elevation,
                            month: month,
                            color: monthColors[month],
                            isHourly: isHourly,
                            hour: Math.floor(minutes / 60),
                            isAboveHorizon: pos.elevation > 0,
                            date: `${year}-${String(month + 1).padStart(2, '0')}-${String(day).padStart(2, '0')}`,
                            time: `${String(Math.floor(minutes / 60)).padStart(2, '0')}:${String(minutes % 60).padStart(2, '0')}`
                        });
                    }
                }
            }
            
            return data;
        }
        
        function createPolarChart(data, latitude, longitude, declination, motto) {
            const canvas = document.getElementById('solarChart');
            const ctx = canvas.getContext('2d');
            
            // Set canvas size
            canvas.width = 800;
            canvas.height = 800;
            
            // Clear canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;
            const maxRadius = Math.min(centerX, centerY) - 50;
            
            // Define elevation range: -70Â° to +70Â°
            const minElev = -70;
            const maxElev = 70;
            const elevRange = maxElev - minElev;
            
            // Draw background
            ctx.fillStyle = '#ffffff';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Draw concentric circles for elevation every 35 degrees
            ctx.strokeStyle = '#e0e0e0';
            ctx.lineWidth = 1;
            for (let elev = minElev; elev <= maxElev; elev += 35) {
                const r = maxRadius * (elev - minElev) / elevRange;
                if (r > 0) {
                    ctx.beginPath();
                    ctx.arc(centerX, centerY, r, 0, 2 * Math.PI);
                    ctx.stroke();
                }
            }
            
            // Draw horizon circle (elevation = 0) in thick black
            const horizonRadius = maxRadius * (0 - minElev) / elevRange;
            ctx.strokeStyle = '#000000';
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.arc(centerX, centerY, horizonRadius, 0, 2 * Math.PI);
            ctx.stroke();
            
            // Draw azimuth lines every 15 degrees
            ctx.strokeStyle = '#e0e0e0';
            ctx.lineWidth = 1;
            for (let az = 0; az < 360; az += 15) {
                const angle = toRadians(az - 90 + declination); // Apply declination rotation
                const x1 = centerX + 20 * Math.cos(angle);
                const y1 = centerY + 20 * Math.sin(angle);
                const x2 = centerX + maxRadius * Math.cos(angle);
                const y2 = centerY + maxRadius * Math.sin(angle);
                
                ctx.beginPath();
                ctx.moveTo(x1, y1);
                ctx.lineTo(x2, y2);
                ctx.stroke();
            }
            
            // Draw direction labels (keep text horizontal despite rotation)
            ctx.fillStyle = '#333333';
            ctx.font = '16px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            
            const labelRadius = maxRadius + 30;
            const directions = [
                {label: 'S', angle: 0},    // South at reference position
                {label: 'SW', angle: 45},
                {label: 'W', angle: 90},   // West
                {label: 'NW', angle: 135},
                {label: 'N', angle: 180},  // North
                {label: 'NE', angle: 225},
                {label: 'E', angle: 270},  // East
                {label: 'SE', angle: 315}
            ];
            
            directions.forEach(dir => {
                const angle = toRadians(dir.angle - 90 + declination); // Apply declination rotation
                const x = centerX + labelRadius * Math.cos(angle);
                const y = centerY + labelRadius * Math.sin(angle);
                ctx.fillText(dir.label, x, y);
            });
            
            // Draw elevation labels
            ctx.textAlign = 'left';
            ctx.fillStyle = '#666666';
            ctx.font = '12px Arial';
            for (let elev = minElev; elev <= maxElev; elev += 35) {
                const r = maxRadius * (elev - minElev) / elevRange;
                if (r > 10) {
                    ctx.fillText(elev + 'Â°', centerX + r + 5, centerY - 5);
                }
            }
            
            // Plot data points and collect CSV data
            const monthColors = ['#FF0000', '#FFA500', '#FFFF00', '#008000', '#0000FF', '#800080', '#FF0000', '#FFA500', '#FFFF00', '#008000', '#0000FF', '#800080'];
            const csvData = [];
            const hourlyMaxData = {}; // Track max elevation for each hour for labeling
            
            data.forEach(point => {
                // Skip points outside elevation range
                if (point.elevation < minElev || point.elevation > maxElev) return;
                
                const r = maxRadius * (point.elevation - minElev) / elevRange;
                const angle = toRadians(point.azimuth - 90 + declination); // Apply declination rotation
                const x = centerX + r * Math.cos(angle);
                const y = centerY + r * Math.sin(angle);
                
                // Track maximum elevation for each hour for labeling
                if (point.isHourly && point.isAboveHorizon) {
                    const hour = point.hour;
                    if (!hourlyMaxData[hour] || point.elevation > hourlyMaxData[hour].elevation) {
                        hourlyMaxData[hour] = {
                            elevation: point.elevation,
                            azimuth: point.azimuth,
                            x: x,
                            y: y
                        };
                    }
                }
                
                // Store CSV data
                csvData.push({
                    date: point.date,
                    time: point.time,
                    azimuth: point.azimuth.toFixed(2),
                    elevation: point.elevation.toFixed(2),
                    plot_x: ((x - centerX) / maxRadius).toFixed(4),
                    plot_y: ((y - centerY) / maxRadius).toFixed(4)
                });
                
                ctx.fillStyle = point.isAboveHorizon ? monthColors[point.month] : '#808080';
                ctx.globalAlpha = point.isAboveHorizon ? 0.8 : 0.3;
                
                ctx.beginPath();
                const radius = point.isHourly ? 3 : 1;
                ctx.arc(x, y, radius, 0, 2 * Math.PI);
                ctx.fill();
            });
            
            ctx.globalAlpha = 1.0;
            
            // Add hour labels just outside the maximum elevation points (summer solstice positions)
            ctx.fillStyle = '#333333';
            ctx.font = '10px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.strokeStyle = '#000000';
            ctx.lineWidth = 1;
            
            Object.keys(hourlyMaxData).forEach(hour => {
                const data = hourlyMaxData[hour];
                // Place label slightly outside the maximum elevation point
                const labelRadius = Math.sqrt((data.x - centerX)**2 + (data.y - centerY)**2) + 15;
                const angle = Math.atan2(data.y - centerY, data.x - centerX);
                const labelX = centerX + labelRadius * Math.cos(angle);
                const labelY = centerY + labelRadius * Math.sin(angle);
                
                // Draw small circle background
                ctx.fillStyle = 'white';
                ctx.beginPath();
                ctx.arc(labelX, labelY, 8, 0, 2 * Math.PI);
                ctx.fill();
                ctx.stroke();
                
                // Draw hour number
                ctx.fillStyle = '#333333';
                ctx.fillText(hour, labelX, labelY);
            });
            
            // Store CSV data globally for download
            window.solarCsvData = csvData;
            
            // Add coordinate info at top and motto at bottom
            ctx.fillStyle = '#333333';
            ctx.font = '14px Arial';
            ctx.textAlign = 'center';
            ctx.fillText(`Latitude: ${latitude}Â°, Longitude: ${longitude}Â°, Declination: ${declination}Â°`, centerX, 30);
            
            // Add motto at bottom if provided
            if (motto.trim()) {
                ctx.fillText(motto, centerX, canvas.height - 20);
            }
            
            // Show chart container
            document.getElementById('chartContainer').style.display = 'block';
            setupDownload();
        }
        
        function setupDownload() {
            const downloadBtn = document.getElementById('downloadBtn');
            downloadBtn.style.display = 'block';
            downloadBtn.innerHTML = 'ðŸ“¥ Download PNG | ðŸ“„ Download CSV';
            
            downloadBtn.onclick = function() {
                // Create dropdown menu for download options
                const menu = document.createElement('div');
                menu.style.cssText = `
                    position: absolute;
                    background: white;
                    border: 2px solid #ccc;
                    border-radius: 8px;
                    box-shadow: 0 4px 12px rgba(0,0,0,0.2);
                    z-index: 1000;
                    padding: 10px;
                    margin-top: 5px;
                `;
                
                const pngBtn = document.createElement('button');
                pngBtn.textContent = 'ðŸ“¥ Download PNG Image';
                pngBtn.style.cssText = `
                    display: block;
                    width: 100%;
                    margin: 5px 0;
                    padding: 8px 12px;
                    border: none;
                    background: #28a745;
                    color: white;
                    border-radius: 4px;
                    cursor: pointer;
                `;
                pngBtn.onclick = downloadPNG;
                
                const csvBtn = document.createElement('button');
                csvBtn.textContent = 'ðŸ“„ Download CSV Data';
                csvBtn.style.cssText = `
                    display: block;
                    width: 100%;
                    margin: 5px 0;
                    padding: 8px 12px;
                    border: none;
                    background: #007bff;
                    color: white;
                    border-radius: 4px;
                    cursor: pointer;
                `;
                csvBtn.onclick = downloadCSV;
                
                menu.appendChild(pngBtn);
                menu.appendChild(csvBtn);
                
                // Position menu below button
                const rect = downloadBtn.getBoundingClientRect();
                menu.style.left = rect.left + 'px';
                menu.style.top = (rect.bottom + window.scrollY) + 'px';
                
                document.body.appendChild(menu);
                
                // Remove menu when clicking elsewhere
                setTimeout(() => {
                    const removeMenu = (e) => {
                        if (!menu.contains(e.target)) {
                            document.body.removeChild(menu);
                            document.removeEventListener('click', removeMenu);
                        }
                    };
                    document.addEventListener('click', removeMenu);
                }, 100);
            };
        }
        
        function downloadPNG() {
            const canvas = document.getElementById('solarChart');
            
            // Create a temporary canvas with higher resolution
            const tempCanvas = document.createElement('canvas');
            const tempCtx = tempCanvas.getContext('2d');
            
            // Set higher resolution (2x for crisp output)
            const scale = 2;
            tempCanvas.width = canvas.width * scale;
            tempCanvas.height = canvas.height * scale;
            tempCtx.scale(scale, scale);
            
            // Draw the original canvas content onto the high-res canvas
            tempCtx.drawImage(canvas, 0, 0);
            
            // Create download link
            tempCanvas.toBlob((blob) => {
                const url = URL.createObjectURL(blob);
                const link = document.createElement('a');
                link.download = `solar-position-lat${document.getElementById('latitude').value}-lon${document.getElementById('longitude').value}.png`;
                link.href = url;
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
                URL.revokeObjectURL(url);
            }, 'image/png', 1.0);
        }
        
        function downloadCSV() {
            if (!window.solarCsvData) {
                alert('No data available for download');
                return;
            }
            
            const headers = ['date', 'time', 'azimuth', 'elevation', 'plot_x', 'plot_y'];
            const csvContent = [
                headers.join(','),
                ...window.solarCsvData.map(row => headers.map(header => row[header]).join(','))
            ].join('\n');
            
            const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
            const link = document.createElement('a');
            const url = URL.createObjectURL(blob);
            link.setAttribute('href', url);
            link.setAttribute('download', `solar-position-data-lat${document.getElementById('latitude').value}-lon${document.getElementById('longitude').value}.csv`);
            link.style.visibility = 'hidden';
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
        }
        
        function showStatus(message, type) {
            const status = document.getElementById('status');
            status.textContent = message;
            status.className = `status ${type}`;
            status.style.display = 'block';
            
            if (type === 'success') {
                setTimeout(() => {
                    status.style.display = 'none';
                }, 3000);
            }
        }
        
        // Generate initial plot
        window.addEventListener('load', () => {
            setTimeout(generatePlot, 500);
        });
    </script>
</body>
</html>